!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	Makefile	/^CC = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS =  -g -MD -Wall -D_FILE_OFFSET_BITS=64$/;"	m
DONE	rpc.h	/^    DONE,	\/\/ duplicate of an RPC we already replied to (have reply)$/;"	e	enum:rpcs::__anon1
FORGOTTEN	rpc.h	/^    FORGOTTEN,	\/\/ duplicate of an old RPC whose reply we've forgotten$/;"	e	enum:rpcs::__anon1
FUSEFLAGS	Makefile	/^FUSEFLAGS= -D_FILE_OFFSET_BITS=64 -DFUSE_USE_VERSION=25 -I\/usr\/local\/include\/fuse -I\/usr\/include\/fuse$/;"	m
INADDR_NONE	host.h	6;"	d
INPROGRESS	rpc.h	/^    INPROGRESS,	\/\/ duplicate of an RPC we're still processing$/;"	e	enum:rpcs::__anon1
IOERR	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
LDFLAGS	Makefile	/^LDFLAGS = -L. -L\/usr\/local\/lib$/;"	m
LDLIBS	Makefile	/^LDLIBS = -lrpc -lfuse -lpthread$/;"	m
NEW	rpc.h	/^    NEW,	\/\/ new RPC, not a duplicate$/;"	e	enum:rpcs::__anon1
NOENT	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
OK	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RETRY	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RPCERR	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
TO	rpc.h	/^  struct TO {$/;"	s	class:rpcc
_next_timeout	rpc.h	/^  struct timespec _next_timeout;$/;"	m	class:rpcc	typeref:struct:rpcc::timespec
_ok	marshall.h	/^  bool _ok;$/;"	m	class:unmarshall
_timeout_cond	rpc.h	/^  pthread_cond_t _timeout_cond;$/;"	m	class:rpcc
_timeout_lock	rpc.h	/^  pthread_mutex_t _timeout_lock;$/;"	m	class:rpcc
_vivaldi	rpc.h	/^  class vivaldi *_vivaldi;$/;"	m	class:rpcc	typeref:class:rpcc::vivaldi
_vivaldi	rpc.h	/^  class vivaldi *_vivaldi;$/;"	m	class:rpcs	typeref:class:rpcs::vivaldi
a	lock_tester.cc	/^lock_protocol::lockid_t a = 1;$/;"	v
acquire	lock_client.cc	/^lock_client::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
acquire	lock_protocol.h	/^    acquire = 0x7001,$/;"	e	enum:lock_protocol::rpc_numbers
add_reply	rpc.cc	/^void rpcs::add_reply(unsigned int clt_nonce, unsigned int xid,$/;"	f	class:rpcs
add_timeout	rpc.cc	/^add_timeout(struct timeval a, int b, struct timespec *result, $/;"	f
addr	host.h	/^  unsigned int addr;$/;"	m	struct:host
atmostonce_failure	rpc.h	/^  static const int atmostonce_failure = -2;$/;"	m	class:rpc_const
attr	rpctest.cc	/^pthread_attr_t attr;$/;"	v
b	lock_tester.cc	/^lock_protocol::lockid_t b = 2;$/;"	v
bind	rpc.cc	/^int rpcs::bind(int a, int &r)$/;"	f	class:rpcs
bind	rpc.cc	/^rpcc::bind(TO to) $/;"	f	class:rpcc
bind	rpc.h	/^  static const unsigned int bind = 1;   \/\/ handler number reserved for bind$/;"	m	class:rpc_const
bind_done	rpc.h	/^  bool bind_done;$/;"	m	class:rpcc
bind_failure	rpc.h	/^  static const int bind_failure = -4;$/;"	m	class:rpc_const
c	fifo.h	/^  pthread_cond_t c; \/\/ q went non-empty$/;"	m	class:fifo
c	lock_tester.cc	/^lock_protocol::lockid_t c = 3;$/;"	v
c	rpc.h	/^    pthread_cond_t c;$/;"	m	struct:rpcc::caller
call	rpc.h	/^rpcc::call( unsigned int proc, R & r, TO to)$/;"	f	class:rpcc
call	rpc.h	/^rpcc::call( unsigned int proc, const A1 & a1, R & r, TO to)$/;"	f	class:rpcc
call	rpc.h	/^rpcc::call( unsigned int proc, const A1 & a1, const A2 & a2,$/;"	f	class:rpcc
call1	rpc.cc	/^rpcc::call1(unsigned int proc, const marshall &req, unmarshall &rep, TO to)$/;"	f	class:rpcc
caller	rpc.cc	/^rpcc::caller::caller(int xxid, unmarshall *xun, uint32_t ip, uint16_t port)$/;"	f	class:rpcc::caller
caller	rpc.h	/^  struct caller {$/;"	s	class:rpcc
calls	rpc.h	/^  std::map<int, caller*> calls;$/;"	m	class:rpcc
cancel	rpc.cc	/^rpcc::cancel(void)$/;"	f	class:rpcc
cancel_failure	rpc.h	/^  static const int cancel_failure = -4;$/;"	m	class:rpc_const
cchan	chan.cc	/^cchan::cchan(sockaddr_in _dst, bool _debug)$/;"	f	class:cchan
cchan	chan.h	/^class cchan {$/;"	c
ch	chan.h	/^    tcpchan *ch;$/;"	m	struct:schan::channel
ch	chan.h	/^  tcpchan *ch;$/;"	m	class:cchan
ch_c	chan.h	/^  pthread_cond_t ch_c;$/;"	m	class:cchan
ch_m	chan.h	/^  pthread_mutex_t ch_m;$/;"	m	class:cchan
chan	rpc.h	/^    int chan;$/;"	m	struct:rpcs::junk
chan	rpc.h	/^  cchan chan;$/;"	m	class:rpcc
chan	rpc.h	/^  schan chan;$/;"	m	class:rpcs
chan_h	chan.h	2;"	d
chan_loop	rpc.cc	/^rpcc::chan_loop()$/;"	f	class:rpcc
channel	chan.h	/^  struct channel {$/;"	s	class:schan
channo	chan.h	/^    int channo;$/;"	m	struct:schan::inbuf
channo	chan.h	/^  int channo;$/;"	m	class:schan
check_grant	lock_tester.cc	/^check_grant(lock_protocol::lockid_t lid)$/;"	f
check_release	lock_tester.cc	/^check_release(lock_protocol::lockid_t lid)$/;"	f
checkduplicate_and_update	rpc.cc	/^rpcs::rpcstate_t rpcs::checkduplicate_and_update(unsigned int clt_nonce,$/;"	f	class:rpcs
cl	lock_client.h	/^  rpcc *cl;$/;"	m	class:lock_client
cleanup_lock	fifo.h	/^  static void cleanup_lock(void *arg) {$/;"	f	class:fifo
cleanup_tcp_loop	chan.h	/^  static void cleanup_tcp_loop(void *arg) {$/;"	f	class:cchan
cleanup_tcp_loop1	chan.h	/^  static void cleanup_tcp_loop1(void *arg) {$/;"	f	class:schan
cleanup_timeout_lock	rpc.h	/^  static void cleanup_timeout_lock(void *arg) {$/;"	f	class:rpcc
client	rpctest.cc	/^rpcc *client;  \/\/ client rpc object$/;"	v
client1	rpctest.cc	/^client1(void *xx)$/;"	f
client2	rpctest.cc	/^client2(void *xx)$/;"	f
client3	rpctest.cc	/^client3(void *xx)$/;"	f
clock_loop	rpc.cc	/^rpcc::clock_loop()$/;"	f	class:rpcc
clt_nonce	rpc.h	/^  int clt_nonce;$/;"	m	class:rpcc
concurrent_test	rpctest.cc	/^void concurrent_test()$/;"	f
connect_m	chan.h	/^  pthread_mutex_t connect_m;$/;"	m	class:cchan
count_mutex	lock_tester.cc	/^pthread_mutex_t count_mutex;$/;"	v
counting	rpc.h	/^  int counting;$/;"	m	class:rpcs
counts	rpc.h	/^  std::map<int, int> counts;$/;"	m	class:rpcs
ct	lock_tester.cc	/^int ct[256];$/;"	v
dead	chan.h	/^  bool dead() { return isdead; }$/;"	f	class:tcpchan
debug	chan.h	/^  bool debug;$/;"	m	class:cchan
debug	chan.h	/^  bool debug;$/;"	m	class:schan
debug	chan.h	/^  bool debug;$/;"	m	class:tcpchan
debug	rpc.h	/^  bool debug;$/;"	m	class:rpcc
debug	rpc.h	/^  bool debug;$/;"	m	class:rpcs
debug	rpctest.cc	/^int debug = false;$/;"	v
dec_nthread	rpc.cc	/^void rpcs::dec_nthread()$/;"	f	class:rpcs
delete_c	rpc.h	/^  pthread_cond_t delete_c;$/;"	m	class:rpcs
delete_m	rpc.h	/^  pthread_mutex_t delete_m;$/;"	m	class:rpcs
deleting	rpc.h	/^  bool deleting;$/;"	m	class:rpcs
deq	fifo.h	/^fifo<T>::deq()$/;"	f	class:fifo
destroy_wait	rpc.h	/^  bool destroy_wait;$/;"	m	class:rpcc
destroy_wait_c	rpc.h	/^  pthread_cond_t destroy_wait_c;$/;"	m	class:rpcc
die	chan.cc	/^tcpchan::die()$/;"	f	class:tcpchan
dispatch	rpc.cc	/^rpcs::dispatch(junk *j)$/;"	f	class:rpcs
done	chan.cc	/^void cchan::done()$/;"	f	class:cchan
done	chan.cc	/^void schan::done(pthread_t myth)$/;"	f	class:schan
done	rpc.h	/^    bool done;$/;"	m	struct:rpcc::caller
dst	chan.h	/^  sockaddr_in dst;$/;"	m	class:cchan
dst	lock_demo.cc	/^std::string dst;$/;"	v
dst	lock_tester.cc	/^std::string dst;$/;"	v
dst	rpc.h	/^  sockaddr_in dst;   \/\/ address of server$/;"	m	class:rpcc
enq	fifo.h	/^fifo<T>::enq(T e)$/;"	f	class:fifo
failure_test	rpctest.cc	/^void failure_test()$/;"	f
fifo	fifo.h	/^class fifo {$/;"	c
fifo	fifo.h	/^fifo<T>::fifo()$/;"	f	class:fifo
fifo_h	fifo.h	2;"	d
free_reply_window	rpc.cc	/^rpcs::free_reply_window(void)$/;"	f	class:rpcs
get_lossy_env	chan.cc	/^get_lossy_env()$/;"	f	file:
got_reply	rpc.cc	/^rpcc::got_reply(unmarshall &rep)$/;"	f	class:rpcc
handle_22	rpctest.cc	/^srv::handle_22(const std::string a, std::string b, std::string &r)$/;"	f	class:srv
handle_bigrep	rpctest.cc	/^srv::handle_bigrep(const int len, std::string &r)$/;"	f	class:srv
handle_fast	rpctest.cc	/^srv::handle_fast(const int a, int &r)$/;"	f	class:srv
handle_slow	rpctest.cc	/^srv::handle_slow(const int a, int &r)$/;"	f	class:srv
handler	rpc.cc	/^handler::handler()$/;"	f	class:handler
handler	rpc.h	/^class handler {$/;"	c
hfiles1	Makefile	/^hfiles1=fifo.h chan.h host.h rpc.h marshall.h method_thread.h lock_protocol.h\\$/;"	m
hfiles2	Makefile	/^hfiles2=yfs_client.h extent_client.h extent_protocol.h extent_server.h$/;"	m
host	host.cc	/^host::host(char *hname, char *pname)$/;"	f	class:host
host	host.h	/^  host() { addr = 0; port = 0; }$/;"	f	struct:host
host	host.h	/^  host(unsigned int a, unsigned int p) { addr = a; port = p; }$/;"	f	struct:host
host	host.h	/^struct host {$/;"	s
host_h	host.h	2;"	d
host_union	host.cc	/^host_union(std::vector<host> a, std::vector<host> b)$/;"	f
i32	rpc.cc	/^unmarshall::i32()$/;"	f	class:unmarshall
i64	rpc.cc	/^unmarshall::i64()$/;"	f	class:unmarshall
id	rpc.h	/^  int id() { return clt_nonce; }$/;"	f	class:rpcc
in_hosts	host.cc	/^in_hosts(host h, std::vector<host> v)$/;"	f
inbuf	chan.h	/^    inbuf() { }$/;"	f	struct:schan::inbuf
inbuf	chan.h	/^  inbuf(std::string xs, int xchan) : s(xs), channo(xchan) { }$/;"	f	struct:schan::inbuf
inbuf	chan.h	/^  struct inbuf {$/;"	s	class:schan
inc_nthread	rpc.cc	/^void rpcs::inc_nthread()$/;"	f	class:rpcs
inq	chan.h	/^  fifo<inbuf> inq;$/;"	m	class:schan
inq	chan.h	/^  fifo<std::string> inq;$/;"	m	class:cchan
intret	rpc.h	/^    int intret;$/;"	m	struct:rpcc::caller
isdead	chan.h	/^  bool isdead; \/\/ tell owning schan or cchan to stop using this tcpchan$/;"	m	class:tcpchan
istr	rpc.cc	/^unmarshall::istr()$/;"	f	class:unmarshall
junk	rpc.cc	/^rpcs::junk::junk(std::string xs, int xchan)$/;"	f	class:rpcs::junk
junk	rpc.h	/^  struct junk {$/;"	s	class:rpcs
lc	lock_demo.cc	/^lock_client *lc;$/;"	v
lc	lock_tester.cc	/^lock_client **lc = new lock_client * [nt];$/;"	v
lock_client	lock_client.cc	/^lock_client::lock_client(std::string dst)$/;"	f	class:lock_client
lock_client	lock_client.h	/^class lock_client {$/;"	c
lock_client_h	lock_client.h	4;"	d
lock_protocol	lock_protocol.h	/^class lock_protocol {$/;"	c
lock_protocol_h	lock_protocol.h	4;"	d
lock_server	lock_server.cc	/^lock_server::lock_server():$/;"	f	class:lock_server
lock_server	lock_server.h	/^class lock_server {$/;"	c
lock_server_h	lock_server.h	5;"	d
lockid_t	lock_protocol.h	/^  typedef unsigned long long lockid_t;$/;"	t	class:lock_protocol
loop	rpc.cc	/^rpcs::loop()$/;"	f	class:rpcs
lose	chan.cc	/^tcpchan::lose()$/;"	f	class:tcpchan
lossy	rpc.h	/^  bool lossy; \/\/ debug: drop some requests and replies$/;"	m	class:rpcs
lossy_percent	chan.h	/^  int lossy_percent;$/;"	m	class:cchan
lossy_percent	chan.h	/^  int lossy_percent;$/;"	m	class:schan
lossy_percent	rpc.h	/^  int lossy_percent; \/\/ percentage of packets to drop if lossy is true$/;"	m	class:rpcs
lossy_test	rpctest.cc	/^void lossy_test()$/;"	f
m	fifo.h	/^  pthread_mutex_t m;$/;"	m	class:fifo
m	rpc.h	/^    pthread_mutex_t m;$/;"	m	struct:rpcc::caller
m	rpc.h	/^  pthread_mutex_t m; \/\/ protect insert\/delete to calls[]$/;"	m	class:rpcc
main	lock_demo.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_tester.cc	/^main(int argc, char *argv[])$/;"	f
main	rpctest.cc	/^main(int argc, char *argv[])$/;"	f
make_sockaddr	rpc.cc	/^make_sockaddr(const char *host, const char *port, struct sockaddr_in *dst){$/;"	f
make_sockaddr	rpc.cc	/^make_sockaddr(const char *hostandport, struct sockaddr_in *dst){$/;"	f
marshall	marshall.h	/^  marshall() { }$/;"	f	class:marshall
marshall	marshall.h	/^class marshall {$/;"	c
marshall_h	marshall.h	2;"	d
method_thread	method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)())$/;"	f
method_thread	method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A), A a)$/;"	f
method_thread	method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2 ), A1 a1, A2 a2)$/;"	f
method_thread	method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2, A3 ), A1 a1, A2 a2, A3 a3)$/;"	f
method_thread_child	method_thread.h	/^method_thread_child()$/;"	f
method_thread_h	method_thread.h	2;"	d
method_thread_parent	method_thread.h	/^method_thread_parent(void *(*fn)(void *), void *arg, bool detach)$/;"	f
nacquire	lock_server.h	/^  int nacquire;$/;"	m	class:lock_server
nonce	rpc.h	/^  int nonce;$/;"	m	class:rpcs
nt	lock_tester.cc	/^int nt = 10;$/;"	v
nthread	rpc.h	/^  int nthread;$/;"	m	class:rpcs
ok	marshall.h	/^  bool ok() { return _ok; }$/;"	f	class:unmarshall
okdone	rpc.cc	/^unmarshall::okdone()$/;"	f	class:unmarshall
operator !=	host.h	/^inline bool operator!=(const host &a, const host &b) {$/;"	f
operator <	host.h	/^inline bool operator<(const host &a, const host &b) {$/;"	f
operator <<	host.cc	/^operator<<(std::ostream &os, const host h)$/;"	f
operator <<	host.cc	/^operator<<(std::ostream &os, const std::vector<host> v)$/;"	f
operator <<	marshall.h	/^operator<<(marshall &m, std::vector<C> v)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, char x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, const std::string &s)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, int x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, short x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, unsigned char x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, unsigned int x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, unsigned long long x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, unsigned long x)$/;"	f
operator <<	rpc.cc	/^operator<<(marshall &m, unsigned short x)$/;"	f
operator =	marshall.h	/^  marshall& operator=(marshall &r) {$/;"	f	class:marshall
operator ==	host.h	/^inline bool operator==(const host &a, const host &b) {$/;"	f
operator >	host.h	/^inline bool operator>(const host &a, const host &b) {$/;"	f
operator >>	marshall.h	/^operator>>(unmarshall &u, std::vector<C> &v)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, char &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, int &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, short &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, std::string &s)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, unsigned char &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, unsigned int &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, unsigned long &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, unsigned long long &x)$/;"	f
operator >>	rpc.cc	/^operator>>(unmarshall &u, unsigned short &x)$/;"	f
other_ip	rpc.h	/^    uint32_t other_ip;$/;"	m	struct:rpcc::caller
other_port	rpc.h	/^    uint16_t other_port;$/;"	m	struct:rpcc::caller
output_loop	chan.cc	/^tcpchan::output_loop()$/;"	f	class:tcpchan
outq	chan.h	/^  fifo<std::string> outq;$/;"	m	class:tcpchan
port	host.h	/^  unsigned int port;$/;"	m	struct:host
port	rpctest.cc	/^int port;$/;"	v
procs	rpc.h	/^  std::map<int, handler *> procs;$/;"	m	class:rpcs
procs_m	rpc.h	/^  pthread_mutex_t procs_m; \/\/ protect insert\/delete to procs[]$/;"	m	class:rpcs
q	fifo.h	/^  std::list<T> q;$/;"	m	class:fifo
rawbyte	rpc.cc	/^marshall::rawbyte(unsigned x)$/;"	f	class:marshall
rawbyte	rpc.cc	/^unmarshall::rawbyte()$/;"	f	class:unmarshall
rawbytes	rpc.cc	/^marshall::rawbytes(const char *p, int n)$/;"	f	class:marshall
rawbytes	rpc.cc	/^unmarshall::rawbytes(unsigned int n)$/;"	f	class:unmarshall
recv	chan.cc	/^cchan::recv()$/;"	f	class:cchan
recv	chan.cc	/^schan::recv(std::string &pdu, int &channo)$/;"	f	class:schan
recv	chan.cc	/^tcpchan::recv()$/;"	f	class:tcpchan
reg	rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, R & r))$/;"	f	class:rpcs
reg	rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, $/;"	f	class:rpcs
reg1	rpc.cc	/^rpcs::reg1(unsigned int proc, handler *h)$/;"	f	class:rpcs
release	lock_client.cc	/^lock_client::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
release	lock_protocol.h	/^    release,$/;"	e	enum:lock_protocol::rpc_numbers
rep	rpc.h	/^    marshall rep;$/;"	m	struct:rpcs::reply_t
rep_present	rpc.h	/^    bool rep_present;$/;"	m	struct:rpcs::reply_t
reply_t	rpc.h	/^    reply_t (unsigned int _xid) {$/;"	f	struct:rpcs::reply_t
reply_t	rpc.h	/^  struct reply_t {$/;"	s	class:rpcs
reply_window	rpc.h	/^  std::map<unsigned int, std::list<reply_t *> > reply_window;$/;"	m	class:rpcs
reply_window_m	rpc.h	/^  pthread_mutex_t reply_window_m; \/\/ protect reply window et al$/;"	m	class:rpcs
rpc_const	rpc.h	/^class rpc_const {$/;"	c
rpc_h	rpc.h	2;"	d
rpc_numbers	lock_protocol.h	/^  enum rpc_numbers {$/;"	g	class:lock_protocol
rpcc	rpc.cc	/^rpcc::rpcc(sockaddr_in _dst, bool _debug)$/;"	f	class:rpcc
rpcc	rpc.h	/^class rpcc {$/;"	c
rpclib	Makefile	/^rpclib=rpc.cc host.cc chan.cc$/;"	m
rpcs	rpc.cc	/^rpcs::rpcs(unsigned int port, bool _debug)$/;"	f	class:rpcs
rpcs	rpc.h	/^class rpcs {$/;"	c
rpcstate_t	rpc.h	/^  } rpcstate_t;$/;"	t	class:rpcs	typeref:enum:rpcs::__anon1
s	chan.h	/^    std::string s;$/;"	m	struct:schan::inbuf
s	chan.h	/^  int s;$/;"	m	class:tcpchan
s	marshall.h	/^  std::istringstream s;$/;"	m	class:unmarshall
s	marshall.h	/^  std::ostringstream s;$/;"	m	class:marshall
s	rpc.h	/^    std::string s;$/;"	m	struct:rpcs::junk
same_hosts	host.cc	/^same_hosts(std::vector<host> a, std::vector<host> b)$/;"	f
schan	chan.cc	/^schan::schan(int port, bool _debug)$/;"	f	class:schan
schan	chan.h	/^class schan {$/;"	c
send	chan.cc	/^cchan::send(std::string pdu)$/;"	f	class:cchan
send	chan.cc	/^schan::send(std::string pdu, int channo)$/;"	f	class:schan
send	chan.cc	/^tcpchan::send(std::string pdu)$/;"	f	class:tcpchan
send1	chan.cc	/^tcpchan::send1(std::string pdu)$/;"	f	class:tcpchan
send_m	chan.h	/^  pthread_mutex_t send_m;$/;"	m	class:cchan
send_m	chan.h	/^  pthread_mutex_t send_m;$/;"	m	class:schan
server	rpctest.cc	/^rpcs *server;  \/\/ server rpc object$/;"	v
set_vivaldi	rpc.h	/^  void set_vivaldi(vivaldi *v) { _vivaldi = v; }$/;"	f	class:rpcc
set_vivaldi	rpc.h	/^  void set_vivaldi(vivaldi *v) { _vivaldi = v; }$/;"	f	class:rpcs
setlossy	chan.h	/^  void setlossy(int p=5) { lossy_percent = p; }$/;"	f	class:schan
setlossy	chan.h	/^  void setlossy(int p=5) { lossy_percent = p;}$/;"	f	class:cchan
setlossy	rpc.cc	/^rpcc::setlossy(bool x)$/;"	f	class:rpcc
setlossy	rpc.cc	/^rpcs::setlossy(bool x)$/;"	f	class:rpcs
setup	chan.cc	/^cchan::setup(sockaddr_in dst)$/;"	f	class:cchan
simple_tests	rpctest.cc	/^simple_tests(rpcc *c)$/;"	f
sin	host.h	/^  sockaddr_in sin() {$/;"	f	struct:host
size	marshall.h	/^  int size() { return s.str().size(); }$/;"	f	class:marshall
srv	rpctest.cc	/^class srv {$/;"	c	file:
startserver	rpctest.cc	/^void startserver(int port)$/;"	f
stat	lock_client.cc	/^lock_client::stat(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
stat	lock_protocol.h	/^    stat$/;"	e	enum:lock_protocol::rpc_numbers
stat	lock_server.cc	/^lock_server::stat(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
status	lock_protocol.h	/^  typedef int status;$/;"	t	class:lock_protocol
str	marshall.h	/^  const std::string str() const { return s.str(); }$/;"	f	class:marshall
str	marshall.h	/^  void str(std::string xs) { s.str(xs); }$/;"	f	class:unmarshall
svr_nonce	rpc.h	/^  int svr_nonce;$/;"	m	class:rpcc
tcp	chan.h	/^  int tcp;$/;"	m	class:schan
tcp_loop	chan.cc	/^schan::tcp_loop()$/;"	f	class:schan
tcp_loop	chan.cc	/^void cchan::tcp_loop()$/;"	f	class:cchan
tcp_loop1	chan.cc	/^schan::tcp_loop1(int s)$/;"	f	class:schan
tcpchan	chan.cc	/^tcpchan::tcpchan(int xs, bool _debug)$/;"	f	class:tcpchan
tcpchan	chan.h	/^class tcpchan {$/;"	c
tcpchans	chan.h	/^  std::map<int, channel> tcpchans;$/;"	m	class:schan
tcpchans_c	chan.h	/^  pthread_cond_t tcpchans_c;$/;"	m	class:schan
tcpchans_m	chan.h	/^  pthread_mutex_t tcpchans_m;$/;"	m	class:schan
test1	lock_tester.cc	/^test1(void)$/;"	f
test2	lock_tester.cc	/^test2(void *x) $/;"	f
test3	lock_tester.cc	/^test3(void *x)$/;"	f
test4	lock_tester.cc	/^test4(void *x)$/;"	f
test5	lock_tester.cc	/^test5(void *x)$/;"	f
th	chan.h	/^    pthread_t th;$/;"	m	struct:schan::channel
th	chan.h	/^  pthread_t th;$/;"	m	class:cchan
th	chan.h	/^  pthread_t th;$/;"	m	class:tcpchan
th_chan_loop	rpc.h	/^  pthread_t th_chan_loop;$/;"	m	class:rpcc
th_clock_loop	rpc.h	/^  pthread_t th_clock_loop;$/;"	m	class:rpcc
th_loop	rpc.h	/^  pthread_t th_loop;$/;"	m	class:rpcs
th_tcp_loop	chan.h	/^  pthread_t th_tcp_loop;$/;"	m	class:schan
timeout_failure	rpc.h	/^  static const int timeout_failure = -1;$/;"	m	class:rpc_const
timeval_subtract	rpc.cc	/^timeval_subtract (struct timeval *result, struct timeval *x, struct timeval *y)$/;"	f
timeval_subtract_positive	rpc.cc	/^timeval_subtract_positive (struct timeval *result, struct timeval *x, struct timeval *y)$/;"	f
to	rpc.h	/^    int to;$/;"	m	struct:rpcc::TO
to	rpc.h	/^  static TO to(int x) { TO t; t.to = x; return t; }$/;"	f	class:rpcc
to_inf	rpc.cc	/^const rpcc::TO rpcc::to_inf = { -1 };$/;"	m	class:rpcc	file:
to_inf	rpc.h	/^  static const TO to_inf;$/;"	m	class:rpcc
un	rpc.h	/^    unmarshall *un;$/;"	m	struct:rpcc::caller
unmarshal_failure	rpc.h	/^  static const int unmarshal_failure = -3;$/;"	m	class:rpc_const
unmarshall	marshall.h	/^  unmarshall() : _ok(true) { }$/;"	f	class:unmarshall
unmarshall	marshall.h	/^  unmarshall(const std::string &xs) : s(xs), _ok(true) { }$/;"	f	class:unmarshall
unmarshall	marshall.h	/^class unmarshall {$/;"	c
update_xid_rep	rpc.cc	/^void rpcc::update_xid_rep(unsigned int xid)$/;"	f	class:rpcc
updatestat	rpc.cc	/^rpcs::updatestat(unsigned int proc)$/;"	f	class:rpcs
waiting	chan.h	/^  bool waiting;$/;"	m	class:cchan
waiting	chan.h	/^  bool waiting;$/;"	m	class:schan
xid	rpc.h	/^    int xid;$/;"	m	struct:rpcc::caller
xid	rpc.h	/^    unsigned int xid;$/;"	m	struct:rpcs::reply_t
xid	rpc.h	/^  unsigned int xid;  \/\/ xid for next request\/call$/;"	m	class:rpcc
xid_rep_window	rpc.h	/^  std::list<unsigned int> xid_rep_window;$/;"	m	class:rpcc
xread	chan.cc	/^tcpchan::xread(void *xp, unsigned int n)$/;"	f	class:tcpchan
xxstatus	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	g	class:lock_protocol
~caller	rpc.cc	/^rpcc::caller::~caller()$/;"	f	class:rpcc::caller
~cchan	chan.cc	/^cchan::~cchan()$/;"	f	class:cchan
~fifo	fifo.h	/^fifo<T>::~fifo()$/;"	f	class:fifo
~handler	rpc.h	/^  virtual ~handler() { }$/;"	f	class:handler
~lock_client	lock_client.h	/^  virtual ~lock_client() {};$/;"	f	class:lock_client
~lock_server	lock_server.h	/^  ~lock_server() {};$/;"	f	class:lock_server
~rpcc	rpc.cc	/^rpcc::~rpcc()$/;"	f	class:rpcc
~rpcs	rpc.cc	/^rpcs::~rpcs()$/;"	f	class:rpcs
~schan	chan.cc	/^schan::~schan()$/;"	f	class:schan
~tcpchan	chan.cc	/^tcpchan::~tcpchan()$/;"	f	class:tcpchan
